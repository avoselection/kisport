# УВМ (Учебная Виртуальная Машина)

**Язык ассемблера** — JSON-массив инструкций. Пример:
[
  {"op":"LDC", "dst":"R1", "imm":305419896},
  {"op":"BSWAP", "dst":"R1"},
  {"op":"ST", "src":"R1", "addr":100}
]

### Регистрная модель
- 8 регистров общего назначения: `R0..R7` (32-битные, беззнаковые внутри УВМ).
- Память объединённая (код + данные), байтовая. Размер по умолчанию: 64 КБ.
- Младший байт вперёд (LE). `BSWAP` меняет порядок байт 32-битного регистра.

### Поддерживаемые инструкции
| Мнемоника | Описание |
|---|---|
| `LDC dst, imm` | Загрузить 32-битную константу в регистр `dst` |
| `LD dst, addr` | Загрузить 32-битное слово из памяти по `addr` в `dst` |
| `ST src, addr` | Записать 32-битное слово из `src` по адресу `addr` |
| `MOV dst, src` | `dst = src` |
| `ADD dst, src` | `dst = (dst + src) mod 2^32` |
| `SUB dst, src` | `dst = (dst - src) mod 2^32` |
| `BSWAP dst`    | перестановка байт 32-битного регистра `dst` |
| `JMP target`   | безусловный переход к метке/адресу |
| `JNZ reg, target` | если `reg != 0`, переход |
| `LABEL name`   | объявление метки (только в JSON-ASM) |

> Примечание: `target` в JSON может быть строкой-меткой или числовым адресом (см. ниже правила адресации).

### JSON-ASM формат (человекочитаемый)
- Файл — JSON-массив объектов. Примеры допустимых инструкций:
  - `{ "op": "LDC", "dst": "R1", "imm": 123 }`
  - `{ "op": "LD",  "dst": "R2", "addr": 1024 }`
  - `{ "op": "ST",  "src": "R2", "addr": 2048 }`
  - `{ "op": "BSWAP", "dst": "R3" }`
  - `{ "op": "ADD", "dst": "R1", "src": "R2" }`
  - `{ "op": "JNZ", "reg": "R1", "target": "loop" }`
  - `{ "op": "LABEL", "name": "loop" }`

#### Адресация и размещение кода
- Ассемблер размещает код последовательно с адреса `0`.
- Метки (`LABEL`) получают адрес начала следующей инструкции.
- Поля `addr`/`target` могут быть  
  **а)** числом (байтовый адрес в памяти) или  
  **б)** строкой-меткой (будет резолвиться во время ассемблирования).

### Двоичный формат машинного кода (выход ассемблера)
- Каждая инструкция кодируется как:
  - `1 байт` — opcode
  - `1 байт` — регистровый байт: high nibble = dst, low nibble = src / reg
  - `4 байта` — immediate/addr (LE), если инструкция требует операнд
- Opcodes:
  - `0x01` LDC (dst, imm)
  - `0x02` LD  (dst, addr)
  - `0x03` ST  (src, addr)
  - `0x04` BSWAP (dst)
  - `0x05` ADD (dst, src)
  - `0x06` SUB (dst, src)
  - `0x07` JMP (addr)
  - `0x08` JNZ (reg, addr)
  - `0x09` MOV (dst, src)

### CLI

### Формат дампа памяти (XML)
```xml
<memory start="0" end="127">
  <cell addr="0">00</cell>
  <cell addr="1">1F</cell>
  ...
</memory>
````

### Примеры программ

#### 1) Копирование массива (этап 3 проверка)

```json
[
  {"op":"LDC","dst":"R0","imm":0},          // i = 0
  {"op":"LDC","dst":"R1","imm":16},         // src = 16
  {"op":"LDC","dst":"R2","imm":64},         // dst = 64
  {"op":"LDC","dst":"R3","imm":7},          // n = 7
  {"op":"LABEL","name":"loop"},
  {"op":"LD","dst":"R4","addr":"R1"},       // LD [src] -> R4  (непрямая адресация: см. ниже)
  {"op":"ST","src":"R4","addr":"R2"},      // ST R4 -> [dst]
  {"op":"ADD","dst":"R1","src":"R5"},     // src += 4  (R5=4, см. инициализацию ниже)
  {"op":"ADD","dst":"R2","src":"R5"},     // dst += 4
  {"op":"ADD","dst":"R0","src":"R6"},     // i += 1   (R6=1)
  {"op":"SUB","dst":"R7","src":"R7"},     // R7=0 (обнулим)
  {"op":"SUB","dst":"R7","src":"R0"},     // R7 = -i  (через мод 2^32)
  {"op":"ADD","dst":"R7","src":"R3"},     // R7 = n - i
  {"op":"JNZ","reg":"R7","target":"loop"}
]
```

> Для удобства непрямая адресация через имя регистра в `addr`/`target` поддерживается: если поле — строка вида `"Rk"`, используется значение регистра как адрес.

#### 2) Поэлементный `bswap()` над вектором длины 7 (этап 5)

```json
[
  {"op":"LDC","dst":"R1","imm":16},
  {"op":"LDC","dst":"R2","imm":64},
  {"op":"LDC","dst":"R3","imm":7},
  {"op":"LDC","dst":"R5","imm":4},   // шаг
  {"op":"LDC","dst":"R6","imm":1},   // инкремент
  {"op":"LDC","dst":"R0","imm":0},   // i=0
  {"op":"LABEL","name":"loop"},
  {"op":"LD","dst":"R4","addr":"R1"},
  {"op":"BSWAP","dst":"R4"},
  {"op":"ST","src":"R4","addr":"R2"},
  {"op":"ADD","dst":"R1","src":"R5"},
  {"op":"ADD","dst":"R2","src":"R5"},
  {"op":"ADD","dst":"R0","src":"R6"},
  {"op":"SUB","dst":"R7","src":"R7"},
  {"op":"SUB","dst":"R7","src":"R0"},
  {"op":"ADD","dst":"R7","src":"R3"},
  {"op":"JNZ","reg":"R7","target":"loop"}
]
```

#### 3) Три примера вычислений

* Сумма 3 чисел, запись в память.
* Разность и абсолютное значение через условный переход.
* Поэлементный сдвиг (эмулируется `ADD`/`SUB`).

### Сборка

* **Windows/Linux**: `pyinstaller -F uvm.py` создаёт однофайловый бинарник.
* **Web/WASM**: содержимое `web/` раздайте как статический сайт (PyScript/pyodide загрузит `uvm.py`).

```
python3 uvm.py build --all   # создаст дистрибутивы (требует pyinstaller)
```
